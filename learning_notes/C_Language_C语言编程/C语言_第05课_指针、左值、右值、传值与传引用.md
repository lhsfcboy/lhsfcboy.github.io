## 前言

C 语言中的函数有传值和传引用（传指针）的区别。本篇将列出讨论大纲。

通过学习，我们将认识到，C 语言中所谓的传引用实际上是通过传递指针的值来实现的。


## 前置知识的复习与内存概念的引入

```c
int a; // 声明变量 a
a = 1; // 将值 1 赋给变量 a
```

等号 `=` 在 C 语言中代表赋值操作，其效果是把等号右边的值，赋给等号左边的变量。这里我们将引入对左值和右值的初步理解：

- 左值：等号左边的，或者说允许出现在等号左边的，通常都是具名对象，也就是变量名。
- 右值：不是左值的就是右值，右值是一个具体的值，比如数字 `10`，或者表达式的临时结果，例如 `a + 5`。

下面我们从内存的角度再看一次上述代码的含义。

第一行，我们声明了变量以后，计算机会给这个变量分配一片相应的内存空间，并在符号表中记录这个内存空间的具体地址。

> 注意：符号表是真实存在的，不是为了方便理解创造的概念。当然这里对于具体细节进行了大幅度的简化。

### 符号表部分

| 标识符 | 类型 | 内存地址           |
| ------ | ------ | ------------------ |
| a      | int    | 0x7FFC1234ABCD   |
| ...... | ...... | ......           |
| ...... | ...... | ......           |

注意：内存地址是示意性的，每次运行程序时可能会变化。

### 变量值部分

| 内存地址          | 值             |
| ----------------- | -------------- |
| ......            | ......         |
| 0x7FFC1234ABCD    | (尚未初始化)    |
| ......            | ......         |
| ......            | ......         |

这里我们升级一下对左值的认识：

- **左值**代表了一片内存空间，有自己的内存地址。例如，变量都是左值。在内存中有一个具体的位置（地址），程序可以通过这个地址来访问或修改对象的值。
```c
int a = 1;   // a 是左值
int b;
b = a;       // b 是左值，a 是右值
```

这里 `a` 是个变量，可是一会在左边当左值，一会在右边当右值，为什么？

当变量出现在右边的时候有一个隐式的转换过程，左值到右值转换（lvalue-to-rvalue conversion）。

- `a` 出现在左边时，表示的是一片内存区域，用伪代码表示为：

  ```
  MemorySpace(a)
  ```

- `a` 出现在右边时，表示的是对应内存区域内的值，有一个隐式的转换过程，用伪代码表示为：

  ```
  ValueOf(MemorySpace(a))
  ```

## 内存角度来看简单的函数执行

传值时，函数内部的参数是传入值的拷贝，而不是原变量本身。

```c
#include <stdio.h>

int sum(int x, int y) {
    return x + y;
}

int main() {
    int a = 3;
    int b = 4;
    int result = sum(a, b);
    
    printf("The sum of %d and %d is: %d\n", a, b, result);
    
    return 0;
}
```

下面我们看看内存里发生了什么

调用函数 `sum` 之前

- 符号表
  
| 标识符 | 类型 | 内存地址           |
| ------ | ------ | ------------------ |
| a      | int    | 0x7FFC1234ABCD   |
| b      | int    | 0x7FFC1234ABCE   |
| ...... | ...... | ......           |

- 变量值部分

| 内存地址编号       | 内存的内容      |
| ----------------- | -------------- |
| ......            | ......         |
| 0x7FFC1234ABCD    | 3              |
| 0x7FFC1234ABCE    | 4              |
| ......            | ......         |


调用函数 `sum` 的过程
- 符号表
这里的示意图与真实情况不符合, 但是没有严重概念性错误

| 标识符          | 类型   | 内存地址           |
| ------          | ------ | ---------------- |
| a               | int    | 0x7FFC1234ABCD   |
| b               | int    | 0x7FFC1234ABCE   |
| ......          | ...... | ......           |
| x of sum()      | int    | 0xABCDEFGH1234   |
| y of sum()      | int    | 0xABCDEFGH1235   |
| return of sum() | int    | 0xABCDEFGH1236   |
- 变量值部分

| 内存地址          | 值             |
| ----------------- | -------------- |
| ......            | ......         |
| 0x7FFC1234ABCD    | 3              |
| 0x7FFC1234ABCE    | 4              |
| ......            | ......         |
| 0xABCDEFGH1234    | 3              |
| 0xABCDEFGH1235    | 4              |
| 0xABCDEFGH1236    | 7              |


传值时，函数内部的参数是传入值的拷贝，而不是原变量本身。因此，在函数内部对这个拷贝的修改不会影响到外部原变量。
## 修改参数的第一次尝试

```c
#include <stdio.h>
void sub(int p);  // 更好的名字是subtract()
int main()
{
    int a = 1;
    sub(a);
    printf("Value of a: %d\n", a);
}
void sub(int p) // 伪代码来说, 这里相当于执行了p = ValueOf(a);
{
    p = p - 1;
}
```

从内存的角度分析，如上程序的执行，并认识到函数的调用是复制了参数的值。

- 符号表的示意图

| 标识符          | 类型   | 内存地址           |
| ------          | ------ | ---------------- |
| a               | int    | 0x7FFC1234ABCD   |
| ......          | ...... | ......           |
| p of sub()      | int    | 0xABCDEFGH1234   |

注意这里没有`return of sub()`, 想想为什么.

- 变量值部分

`subb()`的调用开始时:

| 内存地址          | 值             |
| ----------------- | -------------- |
| ......            | ......         |
| 0x7FFC1234ABCD    | 1              |
| ......            | ......         |
| 0xABCDEFGH1234    | 1              |

`subb()`的调用过程中:

| 内存地址          | 值             |
| ----------------- | -------------- |
| ......            | ......         |
| 0x7FFC1234ABCD    | 1              |
| ......            | ......         |
| 0xABCDEFGH1234    | 0              |

## 指针的介绍

我们先来抽象的理解一下指针. 指针是一种方法论: 对于一个具体的对象, 我们不需要完整的持有它, 只需要保留一个足以找到它的信息. 这个信息就是指针.

例如一座建筑物, 我们只要知道它的地址就能找到, 可以在一张白纸上写下这个地址. 此时这张纸就是一个指针, 它的内容是一处地址, 通过地址指向了一座建筑物.

例如磁盘上的一个文件, 我们只要知道它的完整目录和文件名, 就能找到这个文件. 这些信息可以储存在一个专门的文件之中. 这个文件是一个指针, 它的内容是一个完整的绝对路径.
```
cat path_of_top_secrets.txt
/home/haru/Weekend_Plan_2024.txt
```
这些内容指向了我们的目标文件

在比如, 一个数组 `int array[3] = {0, 10, 20, };`, 对于数组中的(从0起算)第2个元素`20`而言, 我们只要知道数组下标`int index = 2`, 就能得到它的值`printf("%d\n", array[index]);` .
这里, `index`这个整数变量就是一个指针, 它的内容是一个下标, 通过这个下标我们可以访问到第2个元素`20`

再比如, 内存中的一小片区域, 我们只要知道它的内存地址就能找到它. 内存地址这个信息本身也可以存在内存里. C语言中的指针就是这么一种存在.

## C语言中的指针操作
- 声明一个指针变量 `int *p`
  - 这个变量的名字是`p`
  - 这个变量是一个指向一个内存地址, 而且指向的地址处, 将会用于储存`int`类型的变量
- 一元取地址操作符 `&`：需要一个左值参数，返回一个右值
  - 这个操作符作用于一个具体的变量, 返回该变量的内存地址
  - 这样我们就可以给刚才的指针变量赋值了`p = &x;`
  - 可以把具体的值打印出来看看 `printf("Value of p: %p\n", p);`
    - 显然, 人类看到这个值也无法具体使用它
- 一元解引用操作符 `*`：需要一个右值参数，返回一个左值结果
  - 注意, 这里不是声明语句了!!!
  - 如果已经持有一个指针, 想得到它指向的那片内存的具体内容 这种操作叫做解引用
  - `printf("Value of *p: %d\n", *p);`
  - 解引用指针代表了一个内存区域，也是左值. 

```c
#include <stdio.h>
int x = 10;
int y;
y = x + 5; // x 是左值，但在表达式中被转换为右值；x + 5 的结果是右值
int *p = &x; // &x 取地址操作，需要左值，x 是左值
printf("Value of  p: %p\n",  p);
printf("Value of *p: %d\n", *p);
```

## 通过传指针实现对参数的修改
为了在函数中修改外部变量的值，我们可以传递变量的地址，即通过传递指针实现修改。指针实际上是保存了变量的内存地址，而不是变量的值。这样，在函数内部通过指针解引用来修改变量时，真正改变的是指向的内存位置的内容，而非指针本身的值。

```c
#include <stdio.h>

void my_func(int* p)
{
    printf("\nmy_func() is running!!!\n");
    printf("Argument value: %p\n\n", p);
    *p = -1; // 把右端的值赋给左端，*的意思是从指针类型的变量 p 的值所指向的内存区域
    p = NULL;
}

int main()
{
    int a = 1;
    int* p; // 这里定义了一个指针变量 p，注意变量的名字是 p，而不是 *p
    p = &a; // & 符号这里表示取变量的内存地址
    printf("Value of a:          %d\n", a);
    printf("Memory Address of a: %p\n", &a);
    printf("Value of p:          %p\n", p);
    printf("Value of *p:         %d\n", *p);

    my_func(&a); // 等价于 my_func(p); 吗?
    printf("Value of a:          %d\n", a);
    printf("Memory Address of a: %p\n", &a);
    printf("Value of p:          %p\n", p);
    printf("Value of *p:         %d\n", *p);
}
```

**某一次执行的输出**

```
Value of a:          1
Memory Address of a: 0000006CBBDCF7E4
Value of p:          0000006CBBDCF7E4
Value of *p:         1

my_func() is running!!!
Argument value: 0000006CBBDCF7E4

Value of a:          -1
Memory Address of a: 0000006CBBDCF7E4
Value of p:          0000006CBBDCF7E4
Value of *p:         -1
```

### `my_func()`的调用开始时:

- 符号表的示意图

| 标识符          | 类型   | 内存地址          |
| ------          | ------ | ---------------- |
| a               | int    | 0000006CBBDCF7E4 |
| ......          | ...... | ......           |
| p               | int    | 0000006CBBDCABCD |
| ......          | ...... | ......           |
| arg of my_func  | int*   | 0000006CBBDCABEF |

- 变量值部分

| 内存地址          | 值               |
| ----------------- | --------------   |
| ......            | ......           |
| 0000006CBBDCF7E4  | 1                |
| ......            | ......           |
| 0000006CBBDCABCD  | 0000006CBBDCF7E4 |
| ......            | ......           |
| 0000006CBBDCABEF  | 0000006CBBDCF7E4 |

### `my_func()`的调用结束后时:

- 符号表的示意图

| 标识符          | 类型   | 内存地址          |
| ------          | ------ | ---------------- |
| a               | int    | 0000006CBBDCF7E4 |
| ......          | ...... | ......           |
| p               | int    | 0000006CBBDCABCD |

- 变量值部分

| 内存地址          | 值               |
| ----------------- | --------------   |
| ......            | ......           |
| 0000006CBBDCF7E4  | -1               |
| ......            | ......           |
| 0000006CBBDCABCD  | 0000006CBBDCF7E4 |

## 课后习题

**(1) 下面我们试着用函数来实现自增，模仿 `a++` 的效果，请用内存示意图解释这个过程**

```c
#include <stdio.h>
int APlusPlus(int* a) {
    int original_value = *a; // 保存当前的值
    (*a) = original_value + 1; // 递增变量的值
    return original_value; // 返回原始值
}
int main() {
    int x = 5;
    printf("Before: %d\n", x);
    int result = APlusPlus(&x);
    printf("Result: %d\n", result); // 返回原始值
    printf("After:  %d\n", x); // 打印递增后的值
    return 0;
}
```

**(2) 请实现一个函数 `int PlusPlusA()` 要求能实现 `++a` 的效果**
