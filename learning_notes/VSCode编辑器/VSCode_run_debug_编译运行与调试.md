# VS Code下如何编译/调试文件

以C语言为例.

## gcc常用参数

-fdiagnostics-color=always

## 单个文件的编译运行与调试

对于如下的单个C语言文件, `main.c`
```c
#include <stdio.h>
int main()
{
    int sum = 0;
    for (int i = 1; i <= 10; i++)
    {
        sum += i;
        printf("加上 %d 后,当前和为: %d\n", i, sum);
    }
    printf("最终结果: %d\n", sum);
    return 0;
}
```

- 在终端窗口中使用命令行
  `gcc -Wall -Wextra -std=c99 -o main main.c`
- 在终端窗口中使用`make`命令, 对应的`Makefile`示例如下

```make
all: clean build run

build: main.c
	gcc -Wall -Wextra -std=c99 -o main main.c

run: main
	./main

clean:
	rm -f sum_program

.PHONY: all run clean
```

## 使用VS Code的执行工具

第一次点击`Run`运行时, 会出现下拉列表要求我们选择具体debug配置
![image](https://github.com/user-attachments/assets/edfb79cf-713f-4d70-b1be-a4b64baf3a59)

选择高亮的选项后, 会在工作区目录下生成`.vscode/tasks.json`, 并默认添加了一个使用`gcc`的此配置, 处追加了注释部分方便理解

```json
{
    "tasks": [
        {
            "type": "cppbuild", // 指定任务类型为 C/C++ 构建
            "label": "C/C++: gcc.exe build active file", // 任务标签，显示在任务列表中
            "command": "C:\\AMD\\msys64\\ucrt64\\bin\\gcc.exe", // 指定 GCC 编译器的路径
            "args": [
                "-fdiagnostics-color=always", // 启用诊断信息的彩色输出
                "-g", // 生成调试信息
                "${file}", // 当前活动文件作为输入文件
                "-o", // 指定输出文件
                "${fileDirname}\\${fileBasenameNoExtension}.exe" // 输出文件名与源文件同名，后缀为 .exe
            ],
            "options": {
                "cwd": "${fileDirname}" // 设置当前工作目录为源文件所在目录
            },
            "problemMatcher": [
                "$gcc" // 使用 $gcc 作为问题匹配器，捕获编译错误和警告
            ],
            "group": {
                "kind": "build", // 将任务归类为“build”类型
                "isDefault": true // 设置该任务为默认构建任务
            },
            "detail": "Task generated by Debugger." // 任务的详细描述，显示在任务信息中
        }
    ],
    "version": "2.0.0" // tasks.json 配置文件版本
}
```

借助于这个配置, 我们可以设置断点后进行调试运行了.

## 改写为make模式

```json
{
  "tasks": [
    {
      "type": "shell", // 使用 shell 类型任务来执行 make 命令
      "label": "make build", // 任务标签，显示为“Make: Build project”
      "command": "make build", // 运行 make 命令
      "args": [
        // 可以在此添加额外的 make 参数（如需要）
      ],
      "options": {
        "cwd": "${workspaceFolder}" // 设置当前工作目录为项目的根目录
      },
      "problemMatcher": [
        "$gcc" // 使用 $gcc 作为问题匹配器，捕获编译错误和警告
      ],
      "group": {
        "kind": "build", // 将任务归类为“build”类型
        "isDefault": true // 设置该任务为默认构建任务
      },
      "detail": "Task to build the project using make." // 任务的详细描述
    }
  ],
  "version": "2.0.0" // tasks.json 配置文件版本
}
```

但是此时, 按下`Run`按钮依然不能识别到这个任务, 应为`Run`按钮是从`.vscod/launch.json`中取得任务列表

```json
{
  "tasks": [
    {
      "type": "shell", // 使用 shell 类型任务来执行 make 命令
      "label": "make build", // 任务标签，显示为“Make: Build project”
      "command": "make build", // 运行 make 命令
      "args": [
        // 可以在此添加额外的 make 参数（如需要）
      ],
      "options": {
        "cwd": "${workspaceFolder}" // 设置当前工作目录为项目的根目录
      },
      "problemMatcher": [
        "$gcc" // 使用 $gcc 作为问题匹配器，捕获编译错误和警告
      ],
      "group": {
        "kind": "build", // 将任务归类为“build”类型
        "isDefault": true // 设置该任务为默认构建任务
      },
      "detail": "Task to build the project using make." // 任务的详细描述
    }
  ],
  "version": "2.0.0" // tasks.json 配置文件版本
}
```

## 多个文件的编译运行

这里推荐借助`make`命令实现

```json
{
  "version": "2.0.0",
  "tasks": [
    {
      "label": "Run Make",
      "type": "shell",
      "command": "make",
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "problemMatcher": [],
      "detail": "Runs the Make command to build the project."
    }
  ]
}
```
