## 题目

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
```
- [73, 74, 75, 71, 69, 72, 76, 73,]
- [ 1,  1,  4,  2,  1,  1,  0,  0,]
```

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
原链接：https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.md

## 简单遍历
- 初步分析，显然最后一个一定是0
- 理想情况，这是个单调递增的数列
- 特殊情况，这是个常数数列

两层for循环，把至少需要等待的天数就搜出来了。
```python
def dailyTemperatures(temperatures):
    n = len(temperatures)
    answer = [0] * n  # 初始化结果列表
    for i in range(n):
        for j in range(i + 1, n):
            if temperatures[j] > temperatures[i]:
                answer[i] = j - i  # 计算等待天数
                break  # 找到后跳出内层循环
    return answer

# 测试示例
temperatures = [73, 74, 75, 71, 69, 72, 76, 73]
print(dailyTemperatures(temperatures))  # 输出：[1, 1, 4, 2, 1, 1, 0, 0]
```

## 对简单遍历的分析
- 两层循环，时间复杂度是O(n^2)
- 核心的运算是`temperatures[j] > temperatures[i]` 
- 似乎没有充分利用好信息
- 能不能在一次循环内完成呢？

## 对题目再次分析 
本题其实就是找找到一个元素右边第一个比自己大的元素到当前位置的举例

```
转换为柱状图来只管了解一下数据的趋势
|                   *  
|       *           *  
|    *  *           *  
| *  *  *           *  *  
| *  *  *        *  *  *  
| *  *  *  *     *  *  *  
| *  *  *  *     *  *  *  << 70
| *  *  *  *  *  *  *  *  
| *  *  *  *  *  *  *  *  
| *  *  *  *  *  *  *  *  
| *  *  *  *  *  *  *  *  
+--------------------------------
[73,74,75,71,69,72,76,73,] << 柱子高度
[ 0, 1, 2, 3, 4, 5, 6, 7,] << 柱子序号
  +  +  -  -  +  +  -       << 数据的变化

单调递增的部分
[73,74,75,  ,69,72,76,  ,]
单调递增的时候，下一个比自己大的数，就在旁边

单调递减的部分
[  ,  ,75,71,69,  ,76,73,]
单调递减的时候，下一个比自己大的数，一定要从这个递减结束以后才能找到
```

到这里我们可以意识到，问题的关键在于处理处于递减趋势中的数据。

- 处理到 T2 时，比较得到 T2 > T3 那么我们暂时不知道谁是T2 之后比它大的数据
  - 此时还没有着落的是 T2  
- 处理到 T3， 同样无法处理 T3 和 T4
  - 此时还没有着落的是 T2 和 T3，且 T2 > T3
- 处理到 T4 时，可以确认 T4 < T5， 
  - 此时还没有着落的是 T2 和 T3， 
  - 我们也不知道 T2 T3 T5 的大小关系 只知道 T2 > T3
  - 那么需要开始比较他们的大小关系，来确定T5 是否是T2 或 T3的右边第一个更大的值
  - 先比较 T2 vs T5 ，还是先比较 T3 vs T5 ？
  - 我们暂且从 T3 开始比较
    - T3 < T5 所以
  - 再来看T2 和 T5
```
    T2 >     > T3
T5^      T5^      T5^ ?
```    
- 再来看 T6 吧，T6 < T7
  - pass

把以上文字翻译成代码，我们意识到
- 需要有一个变量来储存`还没有着落的元素`
- 这个简单，一个数组不就可以了嘛
  - 储存索引还是值呢？

这个数组与通常意义上的array不同的地方在于
- 我们不对其进行随机访问，随机访问是指通过数组下标访问任意一个值
- 在这个例子中我们只关注最右边的数据
- 添加元素每次都是在最右边
- 删除元素每次都是在最右边

```
再来看看每个柱子比自己的哪些左边的柱子高
|                   *  
|       *           *  
|    *  *           *  
| *  *  *           *  *  
| *  *  *        *  *  *  
| *  *  *  *     *  *  *  
| *  *  *  *     *  *  *  << 70
| *  *  *  *  *  *  *  *  
| *  *  *  *  *  *  *  *  
| *  *  *  *  *  *  *  *  
| *  *  *  *  *  *  *  *  
+--------------------------------
[73,74,75,71,69,72,76,73,] << 柱子高度
[ 0, 1, 2, 3, 4, 5, 6, 7,] << 柱子序号

     0, 0,       4, 0, 3,
        1,       5, 1, 4,
                    2, 5,
                    3,
                    4,
                    5,                         
```

- 我们没有必要一定要按照从左向右的顺序依次给出结果
- 单调栈通常用于解决这种“下一个更大元素”的问题。
