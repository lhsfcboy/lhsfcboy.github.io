# 随机数

## 1. 真随机数的获取成本极高

- **随机** 的定义：
  - 不可精确预测
  - 可能取到所有可能的值
  - 前后值之间没有依赖关系

- 需要注意的是，并不一定要求所有值的出现概率都相等。  
- 除了常见的平均分布（均匀分布）外，现实中还有许多其他分布类型，例如正态分布。  
- [https://www.random.org/](https://www.random.org/) 是一个常见的在线随机数服务网站：  
  - 这是一个商业网站，使用其真随机数需要付费！

---

## 2. 真随机数与人类观感的差异

- 人类对随机性的直观感受：只要与上一个结果不一样就好，往往会忽略某些统计规律。
- **乱序** 与 **随机** 并不完全相同。
- 在音乐播放时的“随机播放”功能，经常会被用户认为“不够随机”。
- 一些游戏中技能具有 30% 的触发概率，也会让玩家产生“是否真的只有 30%？”的疑惑。

---

## 3. 伪随机数的实现

- 一种常见的简单实现方法：取数的平方作为下一步的基础。
- 假设有一个程序返回两位数（00~99）的随机数，过程演示：
  1. 初始种子为 13，计算 \(13^2 = 169\)，取中间两位得到 69。  
  2. \(69^2 = 4761\)，取中间两位得到 61。  
  3. \(61^2 = 3721\)，取中间两位得到 21。  
  4. \(21^2 = 441\)， 取中间两位得到 41。  
  5. \(41^2 = 1681\)，取中间两位得到 81。  
  - 最终得到的序列为 69, 61, 21, 41, 81。  

- 这个序列看上去“随机”，但真的随机吗？
  - 从数学角度来看，若要严格满足“前后无关联，且能覆盖全部可能取值”，需要非常复杂的算法和严格的证明。
  - 现实中，很多生成器在足够多次迭代后会进入某种循环周期（即周期性）。
  - 若仅依赖初始种子作为输入，不从外部获取任何信息，则同样的种子总会产生相同的随机序列。

- 因此经常需要从外部环境引入随机性，最常见的做法是使用**时间**来当作随机数种子。
  - 如果能修改服务器时间，那么在特定时刻生成的随机数也就能被攻击者预测。

---

## 4. 开销小 & 性能稳定

- 理想情况下，每次生成随机数的时间复杂度和运行时间都应大致相同。
- 如果不同，会在某些场景下产生可利用的信息泄露或性能瓶颈。

---

## 5. 练习

1. **只执行一次 `rand()` 函数**，设法让它平均输出 `0 ~ 9` 共十个数字。  
2. **只执行一次 `rand()` 函数**，模拟一次掷色子的结果 `dice_roll()`。  
3. **只使用 `dice_roll()` 函数**，实现平均输出 `0 ~ 9` 这十个数字，不要求程序在有限步骤内结束。  
   - 提示：可以使用“reject sample”策略。
   - 拒绝采样（Rejection Sampling）：先在一个大的离散空间里生成随机数，如果该空间不能被目标分布的大小整除，就丢弃多余部分并重新来过。
   - 相比于“完美可整除”的情况，拒绝采样可能会“浪费”一些投掷，但好处是：
     - 不必设计复杂的映射函数；
     - 可以在理论上证明只要不断重复，最终得到的分布一定是均匀的
4. **只使用 `dice_roll()` 函数**，实现平均输出 `0 ~ 11` 这十二个数字，要求程序能在有限步骤内结束。  
5. **只使用 `dice_roll()` 函数**，实现平均输出 `0 ~ 9` 这十个数字，要求程序能在有限步骤内结束。  
6. 给定一个数组（如 `[1, 2, 3, 4, 5]`），打乱其顺序，使任一顺序都可能被取到，且概率均等。
